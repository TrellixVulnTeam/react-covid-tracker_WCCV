import {
  init_styled_components_browser_esm,
  styled_components_browser_esm_exports
} from "./chunk-DY32EK2A.js";
import {
  __commonJS,
  __toCommonJS,
  require_react
} from "./chunk-UOOVSGC4.js";

// node_modules/grommet/utils/animation.js
var require_animation = __commonJS({
  "node_modules/grommet/utils/animation.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.normalizeTiming = exports.animationObjectStyle = exports.animationEnding = exports.animationBounds = void 0;
    var _styledComponents = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    var PULSE_SIZES = {
      xsmall: 1.001,
      small: 1.01,
      medium: 1.1,
      large: 1.5,
      xlarge: 2
    };
    var SLIDE_SIZES = {
      xsmall: 1,
      small: 5,
      medium: 10,
      large: 50,
      xlarge: 200
    };
    var JIGGLE_SIZES = {
      xsmall: 0.1,
      small: 1,
      medium: 5,
      large: 400,
      xlarge: 1e3
    };
    var ZOOM_SIZES = {
      xsmall: 1e-3,
      small: 0.01,
      medium: 0.05,
      large: 0.1,
      xlarge: 0.5
    };
    var animationBounds = function animationBounds2(type, size) {
      if (size === void 0) {
        size = "medium";
      }
      if (type === "draw") {
        return ["", "stroke-dashoffset: 0"];
      }
      if (type === "fadeIn") {
        return ["opacity: 0;", "opacity: 1;"];
      }
      if (type === "fadeOut") {
        return ["opacity: 1;", "opacity: 0;"];
      }
      if (type === "jiggle") {
        var deg = JIGGLE_SIZES[size];
        return ["transform: rotate(-" + deg + "deg);", "transform: rotate(" + deg + "deg);"];
      }
      if (type === "pulse") {
        return ["transform: scale(1);", "transform: scale(" + PULSE_SIZES[size] + ")"];
      }
      if (type === "rotateRight") {
        return ["transform: rotate(0deg);", "transform: rotate(359deg);"];
      }
      if (type === "rotateLeft") {
        return ["transform: rotate(0deg);", "transform: rotate(-359deg);"];
      }
      if (type === "flipIn") {
        return ["transform: rotateY(90deg);", "transform: rotateY(0);"];
      }
      if (type === "flipOut") {
        return ["transform: rotateY(0);", "transform: rotateY(90deg);"];
      }
      if (type === "slideDown") {
        return ["transform: translateY(-" + SLIDE_SIZES[size] + "%);", "transform: none;"];
      }
      if (type === "slideLeft") {
        return ["transform: translateX(" + SLIDE_SIZES[size] + "%);", "transform: none;"];
      }
      if (type === "slideRight") {
        return ["transform: translateX(-" + SLIDE_SIZES[size] + "%);", "transform: none;"];
      }
      if (type === "slideUp") {
        return ["transform: translateY(" + SLIDE_SIZES[size] + "%);", "transform: none;"];
      }
      if (type === "zoomIn") {
        return ["transform: scale(" + (1 - ZOOM_SIZES[size]) + ");", "transform: none;"];
      }
      if (type === "zoomOut") {
        return ["transform: scale(" + (1 + ZOOM_SIZES[size]) + ");", "transform: none;"];
      }
      return [];
    };
    exports.animationBounds = animationBounds;
    var normalizeTiming = function normalizeTiming2(time, defaultTiming) {
      return typeof time === "number" ? time / 1e3 + "s" : time || defaultTiming;
    };
    exports.normalizeTiming = normalizeTiming;
    var animationEnding = function animationEnding2(type) {
      if (type === "draw") {
        return "linear forwards";
      }
      if (type === "jiggle") {
        return "alternate infinite";
      }
      if (type === "pulse") {
        return "alternate infinite";
      }
      if (type === "rotateRight" || type === "rotateLeft") {
        return "infinite linear";
      }
      return "forwards";
    };
    exports.animationEnding = animationEnding;
    var animationObjectStyle = function animationObjectStyle2(animation, theme, themeObj) {
      var bounds = animationBounds(animation.type, animation.size);
      var animationTheme = themeObj && themeObj.animation || theme.global.animation;
      if (bounds) {
        var animationTransition = (0, _styledComponents.css)(["from{", ";}to{", ";}"], bounds[0], bounds[1]);
        var defaultDuration = function defaultDuration2() {
          return normalizeTiming(animationTheme[animation.type] ? animationTheme[animation.type].duration : animation.duration, animationTheme.duration);
        };
        return (0, _styledComponents.css)(["", " ", " ", " ", ""], (0, _styledComponents.keyframes)(["", ""], animationTransition), normalizeTiming(animation.duration, defaultDuration()), normalizeTiming(animation.delay, "0s"), animationEnding(animation.type));
      }
      return "";
    };
    exports.animationObjectStyle = animationObjectStyle;
  }
});

// node_modules/grommet/utils/mixins.js
var require_mixins = __commonJS({
  "node_modules/grommet/utils/mixins.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.parseMetricToNum = exports.getAvailableAtBadge = exports.fontSize = exports.findAllByType = exports.breakpointStyle = void 0;
    var _styledComponents = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    var parseMetricToNum = function parseMetricToNum2(metric) {
      if (typeof metric === "number")
        return metric;
      if (metric.match(/\s/) && true) {
        console.warn('Invalid single measurement value: "' + metric + '"');
      }
      return parseFloat(metric.match(/\d+(\.\d+)?/), 10);
    };
    exports.parseMetricToNum = parseMetricToNum;
    var fontSize = function fontSize2(size, lineHeight) {
      return (0, _styledComponents.css)(["font-size:", ";line-height:", ";"], function(props) {
        return parseMetricToNum(size) / parseMetricToNum(props.theme.global.font.size) * 1 + "rem";
      }, function(props) {
        return lineHeight || Math.ceil(parseMetricToNum(size) / parseMetricToNum(props.theme.global.lineHeight)) * (parseMetricToNum(props.theme.global.lineHeight) / parseMetricToNum(size)) + "px";
      });
    };
    exports.fontSize = fontSize;
    var breakpointStyle = function breakpointStyle2(breakpoint, content) {
      return (0, _styledComponents.css)(["@media only screen ", "{", ";}"], breakpoint.value && "and (max-width: " + breakpoint.value + "px)", content);
    };
    exports.breakpointStyle = breakpointStyle;
    var findAllByType = function findAllByType2(component, type) {
      var matches = [];
      if (component.type === type) {
        matches.push(component);
      }
      if (component.children) {
        component.children.forEach(function(child) {
          matches = matches.concat(findAllByType2(child, type));
        });
      }
      return matches;
    };
    exports.findAllByType = findAllByType;
    var getAvailableAtBadge = function getAvailableAtBadge2(availableAt, componentType) {
      return [{
        url: "https://storybook.grommet.io/?selectedKind=" + componentType + "-" + availableAt + "&full=0&stories=1&panelRight=0",
        badge: "https://cdn-images-1.medium.com/fit/c/120/120/1*TD1P0HtIH9zF0UEH28zYtw.png",
        label: "Storybook"
      }, {
        url: "https://codesandbox.io/s/github/grommet/grommet-sandbox?initialpath=/" + availableAt.toLowerCase() + "&module=%2Fsrc%2F" + availableAt + ".js",
        badge: "https://codesandbox.io/static/img/play-codesandbox.svg",
        label: "CodeSandbox"
      }];
    };
    exports.getAvailableAtBadge = getAvailableAtBadge;
  }
});

// node_modules/grommet/utils/colors.js
var require_colors = __commonJS({
  "node_modules/grommet/utils/colors.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.normalizeColor = exports.getRGBA = exports.colorIsDark = void 0;
    var normalizeColor = function normalizeColor2(color, theme, dark) {
      var colorSpec = theme.global && theme.global.colors[color] !== void 0 ? theme.global.colors[color] : color;
      var result = colorSpec;
      if (colorSpec) {
        if ((dark === true || dark === void 0 && theme.dark) && colorSpec.dark !== void 0) {
          result = colorSpec.dark;
        } else if ((dark === false || !theme.dark) && colorSpec.light !== void 0) {
          result = colorSpec.light;
        }
      }
      if (result && theme.global && theme.global.colors[result] !== void 0) {
        result = normalizeColor2(result, theme, dark);
      }
      return result;
    };
    exports.normalizeColor = normalizeColor;
    var parseHexToRGB = function parseHexToRGB2(color) {
      return color.length < 7 ? color.match(/[A-Za-z0-9]{1}/g).map(function(v) {
        return parseInt("" + v + v, 16);
      }) : color.match(/[A-Za-z0-9]{2}/g).map(function(v) {
        return parseInt(v, 16);
      });
    };
    var hslToRGB = function hslToRGB2(h, s, l) {
      var r;
      var g;
      var b;
      if (s === 0 || s === "0") {
        r = l;
        g = l;
        b = l;
      } else {
        var hue2rgb = function hue2rgb2(p2, q2, inT) {
          var t = inT;
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 0.16666667)
            return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2)
            return q2;
          if (t < 0.66666667)
            return p2 + (q2 - p2) * (0.66666667 - t) * 6;
          return p2;
        };
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 0.33333333);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 0.33333333);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    };
    var hexExp = /^#[A-Za-z0-9]{3,4}$|^#[A-Za-z0-9]{6,8}$/;
    var rgbExp = /^rgba?\(\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([0-9]*)\s?\)/;
    var rgbaExp = /^rgba?\(\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([0-9]*)\s?,\s?([.0-9]*)\s?\)/;
    var hslExp = /^hsla?\(\s?([0-9]*)\s?,\s?([0-9]*)%?\s?,\s?([0-9]*)%?\s?.*?\)/;
    var canExtractRGBArray = function canExtractRGBArray2(color) {
      return hexExp.test(color) || rgbExp.test(color) || rgbaExp.test(color) || hslExp.test(color);
    };
    var getRGBArray = function getRGBArray2(color) {
      if (hexExp.test(color)) {
        var _parseHexToRGB = parseHexToRGB(color), red = _parseHexToRGB[0], green = _parseHexToRGB[1], blue = _parseHexToRGB[2], alpha = _parseHexToRGB[3];
        return [red, green, blue, alpha !== void 0 ? alpha / 255 : void 0];
      }
      var match = color.match(rgbExp);
      if (match) {
        return match.splice(1).map(function(v) {
          return parseInt(v, 10);
        });
      }
      match = color.match(rgbaExp);
      if (match) {
        return match.splice(1).map(function(v) {
          return parseFloat(v, 10);
        });
      }
      match = color.match(hslExp);
      if (match) {
        var _match$splice$map = match.splice(1).map(function(v) {
          return parseInt(v, 10);
        }), h = _match$splice$map[0], s = _match$splice$map[1], l = _match$splice$map[2];
        return hslToRGB(h / 360, s / 100, l / 100);
      }
      return color;
    };
    var colorIsDark = function colorIsDark2(color) {
      if (color && canExtractRGBArray(color)) {
        var _getRGBArray = getRGBArray(color), red = _getRGBArray[0], green = _getRGBArray[1], blue = _getRGBArray[2], alpha = _getRGBArray[3];
        if (alpha < 0.5)
          return void 0;
        var brightness = (299 * red + 587 * green + 114 * blue) / 1e3;
        return brightness < 125;
      }
      return void 0;
    };
    exports.colorIsDark = colorIsDark;
    var getRGBA = function getRGBA2(color, opacity) {
      if (color && canExtractRGBArray(color)) {
        var _getRGBArray2 = getRGBArray(color), red = _getRGBArray2[0], green = _getRGBArray2[1], blue = _getRGBArray2[2], alpha = _getRGBArray2[3];
        var normalizedAlpha;
        if (opacity !== void 0) {
          normalizedAlpha = opacity;
        } else if (alpha !== void 0) {
          normalizedAlpha = alpha;
        } else {
          normalizedAlpha = 1;
        }
        return "rgba(" + red + ", " + green + ", " + blue + ", " + normalizedAlpha + ")";
      }
      return void 0;
    };
    exports.getRGBA = getRGBA;
  }
});

// node_modules/grommet/utils/background.js
var require_background = __commonJS({
  "node_modules/grommet/utils/background.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.selectedStyle = exports.normalizeBackground = exports.getHoverIndicatorStyle = exports.backgroundStyle = exports.backgroundIsDark = exports.backgroundAndTextColors = exports.activeStyle = void 0;
    var _styledComponents = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    var _colors = require_colors();
    var evalStyle = function evalStyle2(arg, theme) {
      if (arg && Array.isArray(arg) && typeof arg[0] === "function") {
        return arg[0]({
          theme
        });
      }
      return arg;
    };
    var normalizeBackground = function normalizeBackground2(background, theme) {
      var result = background;
      if (background) {
        if (theme.dark && background.dark && typeof background.dark !== "boolean") {
          result = background.dark;
        } else if (!theme.dark && background.light && typeof background.light !== "boolean") {
          result = background.light;
        }
        result = evalStyle(result, theme);
      }
      return result;
    };
    exports.normalizeBackground = normalizeBackground;
    var backgroundIsDark = function backgroundIsDark2(backgroundArg, theme) {
      var background = normalizeBackground(backgroundArg, theme);
      var result;
      if (background) {
        if (typeof background === "object") {
          var color = background.color, dark = background.dark, opacity = background.opacity;
          if (typeof dark === "boolean") {
            result = dark;
          } else if (color && (!opacity || opacity !== "weak")) {
            var backgroundColor = (0, _colors.normalizeColor)(background.color, theme);
            if (backgroundColor) {
              result = (0, _colors.colorIsDark)(backgroundColor);
            }
          }
        } else {
          var _color = (0, _colors.normalizeColor)(background, theme);
          if (_color) {
            result = (0, _colors.colorIsDark)(_color);
          }
        }
      }
      return result;
    };
    exports.backgroundIsDark = backgroundIsDark;
    var darkContext = function darkContext2(backgroundColor) {
      var isDark = (0, _colors.colorIsDark)(backgroundColor);
      if (isDark === void 0)
        return void 0;
      return isDark ? "dark" : "light";
    };
    var backgroundAndTextColors = function backgroundAndTextColors2(backgroundArg, textArg, theme) {
      if (!backgroundArg)
        return [void 0, textArg];
      var global = theme.global;
      var background = normalizeBackground(backgroundArg, theme);
      var text = textArg || global.colors.text;
      var backgroundColor;
      var textColor;
      if (typeof background === "object") {
        if (background.dark === false) {
          textColor = text.light || text;
        } else if (background.dark) {
          textColor = text.dark || text;
        }
        if (background.color) {
          var color = (0, _colors.normalizeColor)(background.color, theme, background.dark);
          var opacity = background.opacity === true ? global.opacity.medium : global.opacity[background.opacity] || background.opacity;
          backgroundColor = (0, _colors.getRGBA)(color, opacity) || color;
          if (!textColor && (opacity === void 0 || opacity > 0.3)) {
            var shade = darkContext(backgroundColor, theme);
            textColor = (0, _colors.normalizeColor)(shade && text[shade] || text, theme);
          }
        }
      } else {
        backgroundColor = (0, _colors.normalizeColor)(background, theme);
        var _shade = darkContext(backgroundColor, theme);
        if (_shade) {
          textColor = (0, _colors.normalizeColor)(text[_shade] || text, theme, _shade === "dark");
        } else {
          if (backgroundColor !== "transparent")
            backgroundColor = void 0;
          if (text)
            textColor = (0, _colors.normalizeColor)(text, theme);
        }
      }
      if (textArg === false)
        textColor = void 0;
      return [backgroundColor, textColor];
    };
    exports.backgroundAndTextColors = backgroundAndTextColors;
    var backgroundStyle = function backgroundStyle2(backgroundArg, theme, textColorArg) {
      if (backgroundArg === void 0)
        return void 0;
      var background = normalizeBackground(backgroundArg, theme);
      if (typeof background === "string" && background.lastIndexOf("url", 0) === 0) {
        return (0, _styledComponents.css)(["background:", " no-repeat center center;background-size:cover;"], background);
      }
      var _backgroundAndTextCol = backgroundAndTextColors(background, textColorArg, theme), backgroundColor = _backgroundAndTextCol[0], textColor = _backgroundAndTextCol[1];
      if (background.image) {
        var backgroundStyles = "\n      " + (backgroundColor ? "background-color: " + backgroundColor + ";" : "") + "\n      background-image: " + background.image + ";\n      background-repeat: " + (background.repeat || "no-repeat") + ";\n      background-position: " + (background.position || "center center") + ";\n      background-size: " + (background.size || "cover") + ";\n    ";
        return (0, _styledComponents.css)(["", " ", ""], textColor ? "color: " + textColor + ";" : "", !background.opacity ? backgroundStyles : "position: relative;\n        z-index: 0;\n        &:before {\n          content: '';\n          position: absolute;\n          top: 0;\n          right: 0;\n          left: 0;\n          bottom: 0;\n          z-index: -1;\n          " + backgroundStyles + "\n          opacity: " + (background.opacity === true ? theme.global.opacity.medium : theme.global.opacity[background.opacity] || background.opacity) + ";\n        }");
      }
      if (backgroundColor) {
        return (0, _styledComponents.css)(["background-color:", ";", ""], backgroundColor, textColor ? "color: " + textColor + ";" : "");
      }
      if (typeof background === "string")
        return (0, _styledComponents.css)(["background:", ";"], (0, _colors.normalizeColor)(background, theme));
      return void 0;
    };
    exports.backgroundStyle = backgroundStyle;
    var activeStyle = (0, _styledComponents.css)(["", ""], function(props) {
      return backgroundStyle((0, _colors.normalizeColor)(props.theme.global.active.background, props.theme), props.theme, props.theme.global.active.color);
    });
    exports.activeStyle = activeStyle;
    var selectedStyle = (0, _styledComponents.css)(["", ""], function(props) {
      return backgroundStyle((0, _colors.normalizeColor)(props.theme.global.selected.background, props.theme), props.theme, props.theme.global.selected.color);
    });
    exports.selectedStyle = selectedStyle;
    var getHoverIndicatorStyle = function getHoverIndicatorStyle2(hoverIndicator, theme) {
      var background;
      var elevation;
      if (hoverIndicator === true || hoverIndicator === "background") {
        background = theme.global.hover.background;
      } else if (typeof hoverIndicator === "object") {
        if (hoverIndicator.elevation || hoverIndicator.background) {
          elevation = hoverIndicator.elevation;
          background = hoverIndicator.background;
        } else
          background = hoverIndicator;
      } else {
        background = hoverIndicator;
      }
      return (0, _styledComponents.css)(["", " ", ""], backgroundStyle(background, theme, theme.global.hover.color), elevation && "box-shadow: " + theme.global.elevation[theme.dark ? "dark" : "light"][elevation] + ";");
    };
    exports.getHoverIndicatorStyle = getHoverIndicatorStyle;
  }
});

// node_modules/grommet/utils/border.js
var require_border = __commonJS({
  "node_modules/grommet/utils/border.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.responsiveBorderStyle = exports.borderStyle = void 0;
    var _styledComponents = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    var _colors = require_colors();
    var _mixins = require_mixins();
    var responsiveBorderStyle = function responsiveBorderStyle2(data, theme) {
      var color = (0, _colors.normalizeColor)(data.color || "border", theme);
      var borderSize = data.size || "xsmall";
      var style = data.style || "solid";
      var side = typeof data === "string" ? data : data.side || "all";
      var breakpoint = theme.box.responsiveBreakpoint && theme.global.breakpoints[theme.box.responsiveBreakpoint];
      if (!breakpoint.borderSize)
        breakpoint.borderSize = theme.global.borderSize;
      var value = breakpoint && (breakpoint.borderSize[borderSize] || borderSize) && style + " " + (breakpoint.borderSize[borderSize] || borderSize) + " " + color;
      if (!value)
        return void 0;
      if (side === "top" || side === "bottom" || side === "left" || side === "right")
        return "border-" + side + ": " + value + ";";
      if (side === "end" || side === "start")
        return "border-inline-" + side + ": " + value + ";";
      if (side === "vertical")
        return "\n      border-left: " + value + ";\n      border-right: " + value + ";\n    ";
      if (side === "horizontal")
        return "\n      border-top: " + value + ";\n      border-bottom: " + value + ";\n    ";
      if (side === "between")
        return void 0;
      return "border: " + value + ";";
    };
    exports.responsiveBorderStyle = responsiveBorderStyle;
    var borderStyle = function borderStyle2(borderData, responsive, theme) {
      var borderStyles = [];
      (Array.isArray(borderData) ? borderData : [borderData]).forEach(function(data) {
        var styles = [];
        var color = (0, _colors.normalizeColor)(data.color || "border", theme);
        var borderSize = data.size || "xsmall";
        var style = data.style || "solid";
        var side = typeof data === "string" ? data : data.side || "all";
        var value = style + " " + (theme.global.borderSize[borderSize] || borderSize) + " " + color;
        var responsiveStyle = responsive && responsiveBorderStyle(data, theme);
        var breakpoint = responsiveStyle && theme.box.responsiveBreakpoint && theme.global.breakpoints[theme.box.responsiveBreakpoint];
        if (side === "top" || side === "bottom" || side === "left" || side === "right") {
          styles.push("border-" + side + ": " + value + ";");
          if (responsiveStyle) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
          }
        } else if (side === "end" || side === "start") {
          styles.push((0, _styledComponents.css)(["border-inline-", ":", ";"], side, value));
          if (responsiveStyle) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
          }
        } else if (side === "vertical") {
          styles.push((0, _styledComponents.css)(["border-left:", ";border-right:", ";"], value, value));
          if (responsiveStyle) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
          }
        } else if (side === "horizontal") {
          styles.push((0, _styledComponents.css)(["border-top:", ";border-bottom:", ";"], value, value));
          if (responsiveStyle) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
          }
        } else if (side === "between") {
        } else {
          styles.push((0, _styledComponents.css)(["border:", ";"], value));
          if (responsiveStyle) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, responsiveStyle));
          }
        }
        borderStyles.push(styles);
      });
      return borderStyles;
    };
    exports.borderStyle = borderStyle;
  }
});

// node_modules/grommet/utils/DOM.js
var require_DOM = __commonJS({
  "node_modules/grommet/utils/DOM.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.shouldKeepFocus = exports.setFocusWithoutScroll = exports.makeNodeUnfocusable = exports.makeNodeFocusable = exports.isNodeBeforeScroll = exports.isNodeAfterScroll = exports.isFocusable = exports.getNewContainer = exports.getFirstFocusableDescendant = exports.findVisibleParent = exports.findScrollParents = exports.findScrollParent = exports.containsFocus = void 0;
    var findScrollParent = function findScrollParent2(element, horizontal) {
      var result;
      if (element) {
        var parent = element.parentNode;
        while (!result && parent && parent.getBoundingClientRect) {
          var rect = parent.getBoundingClientRect();
          if (horizontal) {
            if (rect.width && parent.scrollWidth > rect.width + 10) {
              result = parent;
            }
          } else if (rect.height && parent.scrollHeight > rect.height + 10) {
            result = parent;
          }
          parent = parent.parentNode;
        }
        if (!result) {
          result = document;
        } else if (result.tagName.toLowerCase() === "body") {
          result = document;
        }
      }
      return result;
    };
    exports.findScrollParent = findScrollParent;
    var documentTags = ["html", "body"];
    var findScrollParents = function findScrollParents2(element, horizontal) {
      var result = [];
      if (element) {
        var parent = element.parentNode;
        while (parent && parent.getBoundingClientRect) {
          var rect = parent.getBoundingClientRect();
          if (horizontal) {
            if (rect.width && parent.scrollWidth > rect.width + 10) {
              result.push(parent);
            }
          } else if (rect.height && parent.scrollHeight > rect.height + 10) {
            result.push(parent);
          }
          parent = parent.parentNode;
        }
        if (result.length && documentTags.includes(result[0].tagName.toLowerCase())) {
          result.length = 0;
        }
        result.push(document);
      }
      return result;
    };
    exports.findScrollParents = findScrollParents;
    var containsFocus = function containsFocus2(node) {
      var element = document.activeElement;
      while (element) {
        if (element === node)
          break;
        element = element.parentElement;
      }
      return !!element;
    };
    exports.containsFocus = containsFocus;
    var isFocusable = function isFocusable2(element) {
      var tagName = element.tagName.toLowerCase();
      return tagName === "input" || tagName === "select" || tagName === "textarea";
    };
    exports.isFocusable = isFocusable;
    var getFirstFocusableDescendant = function getFirstFocusableDescendant2(element) {
      var children = element.getElementsByTagName("*");
      for (var i = 0; i < children.length; i += 1) {
        var child = children[i];
        if (isFocusable(child)) {
          return child;
        }
      }
      return void 0;
    };
    exports.getFirstFocusableDescendant = getFirstFocusableDescendant;
    var shouldKeepFocus = function shouldKeepFocus2() {
      var element = document.activeElement;
      if (isFocusable(element))
        return true;
      return !!getFirstFocusableDescendant(element);
    };
    exports.shouldKeepFocus = shouldKeepFocus;
    var getNewContainer = function getNewContainer2(target, targetChildPosition) {
      if (target === void 0) {
        target = document.body;
      }
      var container = document.createElement("div");
      if (targetChildPosition === "first") {
        target.prepend(container);
      } else {
        target.appendChild(container);
      }
      return container;
    };
    exports.getNewContainer = getNewContainer;
    var setFocusWithoutScroll = function setFocusWithoutScroll2(element) {
      var x = window.scrollX;
      var y = window.scrollY;
      element.focus();
      window.scrollTo(x, y);
    };
    exports.setFocusWithoutScroll = setFocusWithoutScroll;
    var TABINDEX = "tabindex";
    var TABINDEX_STATE = "data-g-tabindex";
    var makeNodeFocusable = function makeNodeFocusable2(node) {
      if (!node.hasAttribute("aria-live")) {
        node.removeAttribute("aria-hidden");
        var elements = node.getElementsByTagName("*");
        Array.prototype.filter.call(elements || [], function(element) {
          return element.hasAttribute(TABINDEX_STATE);
        }).forEach(function(element) {
          var prior = element.getAttribute(TABINDEX_STATE);
          if (prior >= 0) {
            element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));
          } else if (prior === "none") {
            element.removeAttribute(TABINDEX);
          }
          element.removeAttribute(TABINDEX_STATE);
        });
      }
    };
    exports.makeNodeFocusable = makeNodeFocusable;
    var autoFocusingTags = /(a|area|input|select|textarea|button|iframe)$/;
    var makeNodeUnfocusable = function makeNodeUnfocusable2(node) {
      if (!node.hasAttribute("aria-live")) {
        node.setAttribute("aria-hidden", true);
        var elements = node.getElementsByTagName("*");
        Array.prototype.filter.call(elements || [], function(element) {
          return element.getAttribute(TABINDEX) !== null;
        }).forEach(function(element) {
          element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));
          element.setAttribute(TABINDEX, -1);
        });
        Array.prototype.filter.call(elements || [], function(element) {
          var currentTag = element.tagName.toLowerCase();
          return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;
        }).forEach(function(element) {
          element.setAttribute(TABINDEX_STATE, "none");
          element.setAttribute(TABINDEX, -1);
        });
      }
    };
    exports.makeNodeUnfocusable = makeNodeUnfocusable;
    var findVisibleParent = function findVisibleParent2(element) {
      if (element) {
        return element.offsetParent ? element : findVisibleParent2(element.parentElement) || element;
      }
      return void 0;
    };
    exports.findVisibleParent = findVisibleParent;
    var isNodeAfterScroll = function isNodeAfterScroll2(node, target) {
      var _node$getBoundingClie = node.getBoundingClientRect(), bottom = _node$getBoundingClie.bottom;
      var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {
        height: 0,
        top: 0
      }, height = _ref.height, top = _ref.top;
      return bottom >= top + height;
    };
    exports.isNodeAfterScroll = isNodeAfterScroll;
    var isNodeBeforeScroll = function isNodeBeforeScroll2(node, target) {
      var _node$getBoundingClie2 = node.getBoundingClientRect(), top = _node$getBoundingClie2.top;
      var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {
        top: 0
      }, targetTop = _ref2.top;
      return top <= targetTop;
    };
    exports.isNodeBeforeScroll = isNodeBeforeScroll;
  }
});

// node_modules/grommet/utils/graphics.js
var require_graphics = __commonJS({
  "node_modules/grommet/utils/graphics.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.translateEndAngle = exports.polarToCartesian = exports.baseUnit = exports.arcCommands = void 0;
    var POST_DECIMAL_DIGITS = 10;
    var baseUnit = 24;
    exports.baseUnit = baseUnit;
    var polarToCartesian = function polarToCartesian2(centerX, centerY, radius, angleInDegrees) {
      var angleInRadians = (angleInDegrees - 90) * Math.PI / 180;
      return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians)
      };
    };
    exports.polarToCartesian = polarToCartesian;
    var arcCommands = function arcCommands2(centerX, centerY, radius, startAngle, endAngle) {
      var normalizedEndAngle = endAngle;
      if (endAngle > startAngle && endAngle - startAngle >= 360) {
        normalizedEndAngle = startAngle + 359.99;
      }
      var start = polarToCartesian(centerX, centerY, radius, normalizedEndAngle);
      var end = polarToCartesian(centerX, centerY, radius, startAngle);
      var arcSweep = normalizedEndAngle - startAngle <= 180 ? "0" : "1";
      var d = ["M", start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS), "A", radius.toFixed(POST_DECIMAL_DIGITS), radius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 0, end.x.toFixed(POST_DECIMAL_DIGITS), end.y.toFixed(POST_DECIMAL_DIGITS)].join(" ");
      return d;
    };
    exports.arcCommands = arcCommands;
    var translateEndAngle = function translateEndAngle2(startAngle, anglePer, value) {
      return Math.max(0, startAngle + anglePer * value) % 360;
    };
    exports.translateEndAngle = translateEndAngle;
  }
});

// node_modules/grommet/utils/responsive.js
var require_responsive = __commonJS({
  "node_modules/grommet/utils/responsive.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.getDeviceBreakpoint = exports.getBreakpointStyle = exports.getBreakpoint = void 0;
    var getBreakpoint = function getBreakpoint2(viewportWidth, theme) {
      var sortedBreakpoints = Object.keys(theme.global.breakpoints).sort(function(a, b) {
        var first = theme.global.breakpoints[a];
        var second = theme.global.breakpoints[b];
        if (!first)
          return 1;
        if (!second)
          return -1;
        if (!first.value)
          return 1;
        if (!second.value)
          return -1;
        return first.value - second.value;
      });
      var lastBreakpoint = sortedBreakpoints[sortedBreakpoints.length - 1];
      var result = sortedBreakpoints.find(function(name) {
        var breakpoint = theme.global.breakpoints[name];
        return !breakpoint.value || breakpoint.value >= viewportWidth ? name : false;
      });
      return result || lastBreakpoint;
    };
    exports.getBreakpoint = getBreakpoint;
    var getDeviceBreakpoint = function getDeviceBreakpoint2(type, theme) {
      return theme.global.deviceBreakpoints[type];
    };
    exports.getDeviceBreakpoint = getDeviceBreakpoint;
    var getBreakpointStyle = function getBreakpointStyle2(theme, breakpointSize) {
      var breakpoint = breakpointSize && theme.global.breakpoints[breakpointSize] || {};
      if (!breakpoint.edgeSize)
        breakpoint.edgeSize = theme.global.edgeSize;
      if (!breakpoint.borderSize)
        breakpoint.borderSize = theme.global.borderSize;
      if (!breakpoint.size)
        breakpoint.size = theme.global.size;
      return breakpoint;
    };
    exports.getBreakpointStyle = getBreakpointStyle;
  }
});

// node_modules/grommet/utils/styles.js
var require_styles = __commonJS({
  "node_modules/grommet/utils/styles.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.widthStyle = exports.unfocusStyle = exports.textAlignStyle = exports.sizeStyle = exports.roundStyle = exports.plainInputStyle = exports.overflowStyle = exports.kindPartStyles = exports.inputStyle = exports.heightStyle = exports.getInputPadBySide = exports.genericStyles = exports.focusStyle = exports.fillStyle = exports.edgeStyle = exports.disabledStyle = exports.controlBorderStyle = exports.baseStyle = exports.alignStyle = exports.alignContentStyle = void 0;
    var _styledComponents = (init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports));
    var _background = require_background();
    var _colors = require_colors();
    var _responsive = require_responsive();
    var _mixins = require_mixins();
    var baseStyle = (0, _styledComponents.css)(["font-family:", ";font-size:", ";line-height:", ";font-weight:", ";", " box-sizing:border-box;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;"], function(props) {
      return props.theme.global.font.family;
    }, function(props) {
      return props.theme.global.font.size;
    }, function(props) {
      return props.theme.global.font.height;
    }, function(props) {
      return props.theme.global.font.weight;
    }, function(props) {
      return !props.plain && (0, _background.backgroundStyle)(props.theme.baseBackground, props.theme);
    });
    exports.baseStyle = baseStyle;
    var controlBorderStyle = (0, _styledComponents.css)(["border:", " solid ", ";border-radius:", ";"], function(props) {
      return props.theme.global.control.border.width;
    }, function(props) {
      return (0, _colors.normalizeColor)(props.theme.global.control.border.color || "border", props.theme);
    }, function(props) {
      return props.theme.global.control.border.radius;
    });
    exports.controlBorderStyle = controlBorderStyle;
    var edgeStyle = function edgeStyle2(kind, data, responsive, responsiveBreakpoint, theme) {
      var breakpoint = responsiveBreakpoint && theme.global.breakpoints[responsiveBreakpoint];
      if (typeof data === "string") {
        return (0, _styledComponents.css)(["", ":", ";", ";"], kind, theme.global.edgeSize[data] || data, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n        " + kind + ": " + (breakpoint.edgeSize[data] || data) + ";\n      ") : "");
      }
      var result = [];
      var horizontal = data.horizontal, vertical = data.vertical, top = data.top, bottom = data.bottom, left = data.left, right = data.right;
      var horizontalVerticalEqual = horizontal && vertical && horizontal === vertical;
      var allSidesEqual = top && bottom && left && right && top === bottom === left === right;
      if (horizontalVerticalEqual || allSidesEqual) {
        var value = horizontalVerticalEqual ? horizontal : top;
        return (0, _styledComponents.css)(["", ":", ";", ";"], kind, theme.global.edgeSize[value] || value, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n        " + kind + ": " + (breakpoint.edgeSize[value] || value) + ";\n      ") : "");
      }
      if (horizontal) {
        result.push((0, _styledComponents.css)(["", "-left:", ";", "-right:", ";", ";"], kind, theme.global.edgeSize[horizontal] || horizontal, kind, theme.global.edgeSize[horizontal] || horizontal, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-left: " + (breakpoint.edgeSize[horizontal] || horizontal) + ";\n          " + kind + "-right: " + (breakpoint.edgeSize[horizontal] || horizontal) + ";\n        ") : ""));
      }
      if (vertical) {
        result.push((0, _styledComponents.css)(["", "-top:", ";", "-bottom:", ";", ";"], kind, theme.global.edgeSize[vertical] || vertical, kind, theme.global.edgeSize[vertical] || vertical, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-top: " + (breakpoint.edgeSize[vertical] || vertical) + ";\n          " + kind + "-bottom: " + (breakpoint.edgeSize[vertical] || vertical) + ";\n        ") : ""));
      }
      if (top) {
        result.push((0, _styledComponents.css)(["", "-top:", ";", ";"], kind, theme.global.edgeSize[top] || top, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-top: " + (breakpoint.edgeSize[top] || top) + ";\n        ") : ""));
      }
      if (bottom) {
        result.push((0, _styledComponents.css)(["", "-bottom:", ";", ";"], kind, theme.global.edgeSize[bottom] || bottom, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-bottom: " + (breakpoint.edgeSize[bottom] || bottom) + ";\n        ") : ""));
      }
      if (left) {
        result.push((0, _styledComponents.css)(["", "-left:", ";", ";"], kind, theme.global.edgeSize[left] || left, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-left: " + (breakpoint.edgeSize[left] || left) + ";\n        ") : ""));
      }
      if (right) {
        result.push((0, _styledComponents.css)(["", "-right:", ";", ";"], kind, theme.global.edgeSize[right] || right, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-right: " + (breakpoint.edgeSize[right] || right) + ";\n        ") : ""));
      }
      if (data.start) {
        result.push((0, _styledComponents.css)(["", "-inline-start:", ";", ";"], kind, theme.global.edgeSize[data.start] || data.start, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-inline-start: " + (breakpoint.edgeSize[data.start] || data.start) + ";\n        ") : ""));
      }
      if (data.end) {
        result.push((0, _styledComponents.css)(["", "-inline-end:", ";", ";"], kind, theme.global.edgeSize[data.end] || data.end, responsive && breakpoint ? (0, _mixins.breakpointStyle)(breakpoint, "\n          " + kind + "-inline-end: " + (breakpoint.edgeSize[data.end] || data.end) + ";\n        ") : ""));
      }
      return result;
    };
    exports.edgeStyle = edgeStyle;
    var fillStyle = function fillStyle2(fillProp) {
      if (fillProp === "horizontal") {
        return "width: 100%;";
      }
      if (fillProp === "vertical") {
        return "height: 100%;";
      }
      if (fillProp) {
        return "\n      width: 100%;\n      height: 100%;\n    ";
      }
      return void 0;
    };
    exports.fillStyle = fillStyle;
    var focusStyles = function focusStyles2(props, _temp) {
      var _ref = _temp === void 0 ? {} : _temp, forceOutline = _ref.forceOutline, justBorder = _ref.justBorder;
      var focus = props.theme.global.focus;
      if (!focus || forceOutline && !focus.outline) {
        var color = (0, _colors.normalizeColor)("focus", props.theme);
        if (color)
          return "outline: 2px solid " + color + ";";
        return "";
      }
      if (focus.outline && (!focus.border || !justBorder)) {
        if (typeof focus.outline === "object") {
          var _color = (0, _colors.normalizeColor)(focus.outline.color || "focus", props.theme);
          var size = focus.outline.size || "2px";
          return "\n        outline-offset: 0px;\n        outline: " + size + " solid " + _color + ";\n      ";
        }
        return "outline: " + focus.outline + ";";
      }
      if (focus.shadow && (!focus.border || !justBorder)) {
        if (typeof focus.shadow === "object") {
          var _color2 = (0, _colors.normalizeColor)(
            focus.border && focus.border.color || focus.shadow.color || "focus",
            props.theme
          );
          var _size = focus.shadow.size || "2px";
          return "\n        outline: none;\n        box-shadow: 0 0 " + _size + " " + _size + " " + _color2 + ";\n      ";
        }
        return "\n      outline: none;\n      box-shadow: " + focus.shadow + ";\n    ";
      }
      if (focus.border) {
        var _color3 = (0, _colors.normalizeColor)(focus.border.color || "focus", props.theme);
        return "\n      outline: none;\n      border-color: " + _color3 + ";\n    ";
      }
      return "";
    };
    var unfocusStyles = function unfocusStyles2(props, _temp2) {
      var _ref2 = _temp2 === void 0 ? {} : _temp2, forceOutline = _ref2.forceOutline, justBorder = _ref2.justBorder;
      var focus = props.theme.global.focus;
      if (!focus || forceOutline && !focus.outline) {
        var color = (0, _colors.normalizeColor)("focus", props.theme);
        if (color)
          return "outline: none;";
        return "";
      }
      if (focus.outline && (!focus.border || !justBorder)) {
        if (typeof focus.outline === "object") {
          return "\n        outline-offset: 0px;\n        outline: none;\n      ";
        }
        return "outline: none;";
      }
      if (focus.shadow && (!focus.border || !justBorder)) {
        if (typeof focus.shadow === "object") {
          return "\n        outline: none;\n        box-shadow: none;\n      ";
        }
        return "\n      outline: none;\n      box-shadow: none;\n    ";
      }
      if (focus.border) {
        return "\n      outline: none;\n      border-color: none;\n    ";
      }
      return "";
    };
    var focusStyle = function focusStyle2(_temp3) {
      var _ref3 = _temp3 === void 0 ? {} : _temp3, forceOutline = _ref3.forceOutline, justBorder = _ref3.justBorder, skipSvgChildren = _ref3.skipSvgChildren;
      return (0, _styledComponents.css)(["", " ", " ", ""], function(props) {
        return !skipSvgChildren && "\n  > circle,\n  > ellipse,\n  > line,\n  > path,\n  > polygon,\n  > polyline,\n  > rect {\n    " + focusStyles(props) + "\n  }";
      }, function(props) {
        return focusStyles(props, {
          forceOutline,
          justBorder
        });
      }, !forceOutline && "\n  ::-moz-focus-inner {\n    border: 0;\n  }\n  ");
    };
    exports.focusStyle = focusStyle;
    var unfocusStyle = function unfocusStyle2(_temp4) {
      var _ref4 = _temp4 === void 0 ? {} : _temp4, forceOutline = _ref4.forceOutline, justBorder = _ref4.justBorder, skipSvgChildren = _ref4.skipSvgChildren;
      return (0, _styledComponents.css)(["", " ", " ", ""], function(props) {
        return !skipSvgChildren && "\n  > circle,\n  > ellipse,\n  > line,\n  > path,\n  > polygon,\n  > polyline,\n  > rect {\n    " + unfocusStyles(props) + "\n  }";
      }, function(props) {
        return unfocusStyles(props, {
          forceOutline,
          justBorder
        });
      }, !forceOutline && "\n  ::-moz-focus-inner {\n    border: 0;\n  }\n  ");
    };
    exports.unfocusStyle = unfocusStyle;
    var adjustPad = function adjustPad2(props, value) {
      return (0, _mixins.parseMetricToNum)((props.theme.global.edgeSize[value] || value) + "px") + (0, _mixins.parseMetricToNum)(props.theme.global.control.border.width + "px") + "px";
    };
    var getInputPadBySide = function getInputPadBySide2(props, side) {
      if (typeof props.theme.global.input.padding !== "object") {
        var _adjustedPad = adjustPad(props, props.theme.global.input.padding);
        return _adjustedPad;
      }
      var orientation;
      if (side === "left" || side === "right")
        orientation = "horizontal";
      else if (side === "top" || side === "bottom")
        orientation = "vertical";
      else
        orientation = void 0;
      var pad = props.theme.global.input.padding[side] || props.theme.global.input.padding[orientation];
      var adjustedPad = adjustPad(props, pad);
      return adjustedPad;
    };
    exports.getInputPadBySide = getInputPadBySide;
    var placeholderColor = (0, _styledComponents.css)(["color:", ";"], function(props) {
      return (0, _colors.normalizeColor)(props.theme.global.colors.placeholder, props.theme);
    });
    var placeholderStyle = (0, _styledComponents.css)(["&::-webkit-input-placeholder{", ";}&::-moz-placeholder{", ";}&:-ms-input-placeholder{", ";}"], placeholderColor, placeholderColor, placeholderColor);
    var inputSizeStyle = function inputSizeStyle2(props) {
      var data = props.theme.text[props.size];
      if (!data) {
        return (0, _styledComponents.css)(["font-size:", ";"], props.size);
      }
      return (0, _styledComponents.css)(["font-size:", ";line-height:", ";"], data.size, data.height);
    };
    var inputStyle = (0, _styledComponents.css)(["box-sizing:border-box;", " font-family:inherit;border:none;-webkit-appearance:none;background:transparent;color:inherit;width:100%;", " ", " ", " margin:0;", " &:focus{", ";}", " ", "::-webkit-search-decoration{-webkit-appearance:none;}&::-moz-focus-inner{border:none;outline:none;}&:-moz-placeholder,&::-moz-placeholder{opacity:1;}", ""], function(props) {
      var _props$theme$text$pro;
      return "font-size: " + (props.theme.global.input.font.size ? ((_props$theme$text$pro = props.theme.text[props.theme.global.input.font.size]) == null ? void 0 : _props$theme$text$pro.size) || props.theme.global.input.font.size : "inherit") + ";";
    }, function(props) {
      return props.theme.global.input.font.height && "line-height: " + props.theme.global.input.font.height + ";";
    }, function(props) {
      return props.theme.global.input.padding && typeof props.theme.global.input.padding !== "object" ? "padding: " + ((0, _mixins.parseMetricToNum)(props.theme.global.edgeSize[props.theme.global.input.padding] || props.theme.global.input.padding) - (0, _mixins.parseMetricToNum)(props.theme.global.control.border.width)) + "px;" : edgeStyle("padding", props.theme.global.input.padding, props.responsive, props.theme.box.responsiveBreakpoint, props.theme);
    }, function(props) {
      return (props.theme.global.input.weight || props.theme.global.input.font.weight) && (0, _styledComponents.css)(["font-weight:", ";"], props.theme.global.input.weight || props.theme.global.input.font.weight);
    }, function(props) {
      return props.size && inputSizeStyle(props);
    }, function(props) {
      return (!props.plain || props.focusIndicator) && focusStyle();
    }, controlBorderStyle, placeholderStyle, function(props) {
      return props.theme.global.input.extend;
    });
    exports.inputStyle = inputStyle;
    var overflowStyle = function overflowStyle2(overflowProp) {
      if (typeof overflowProp === "string") {
        return (0, _styledComponents.css)(["overflow:", ";"], overflowProp);
      }
      return (0, _styledComponents.css)(["", " ", ";"], overflowProp.horizontal && "overflow-x: " + overflowProp.horizontal + ";", overflowProp.vertical && "overflow-y: " + overflowProp.vertical + ";");
    };
    exports.overflowStyle = overflowStyle;
    var ALIGN_SELF_MAP = {
      center: "center",
      end: "flex-end",
      start: "flex-start",
      stretch: "stretch"
    };
    var genericStyles = (0, _styledComponents.css)(["", " ", " ", ""], function(props) {
      return props.alignSelf && "align-self: " + ALIGN_SELF_MAP[props.alignSelf] + ";";
    }, function(props) {
      return props.gridArea && "grid-area: " + props.gridArea + ";";
    }, function(props) {
      return props.margin && props.theme.global && edgeStyle("margin", props.margin, props.responsive, props.theme.global.edgeSize.responsiveBreakpoint, props.theme);
    });
    exports.genericStyles = genericStyles;
    var disabledStyle = function disabledStyle2(componentStyle) {
      return (0, _styledComponents.css)(["opacity:", ";cursor:default;"], function(props) {
        return componentStyle || props.theme.global.control.disabled.opacity;
      });
    };
    exports.disabledStyle = disabledStyle;
    var sizeStyle = function sizeStyle2(name, value, theme) {
      return (0, _styledComponents.css)(["", ":", ";"], name, theme.global.size[value] || value);
    };
    exports.sizeStyle = sizeStyle;
    var plainInputStyle = (0, _styledComponents.css)(["outline:none;border:none;"]);
    exports.plainInputStyle = plainInputStyle;
    var kindPartStyles = function kindPartStyles2(obj, theme, colorValue) {
      var styles = [];
      if (obj.padding || obj.pad) {
        var pad = obj.padding || obj.pad;
        if (pad.vertical || pad.horizontal)
          styles.push("padding: " + (theme.global.edgeSize[pad.vertical] || pad.vertical || 0) + " " + (theme.global.edgeSize[pad.horizontal] || pad.horizontal || 0) + ";");
        else
          styles.push("padding: " + (theme.global.edgeSize[pad] || pad || 0) + ";");
      }
      if (obj.background)
        styles.push((0, _background.backgroundStyle)(colorValue || obj.background, theme, obj.color || (Object.prototype.hasOwnProperty.call(obj, "color") && obj.color === void 0 ? false : void 0)));
      else if (obj.color)
        styles.push("color: " + (0, _colors.normalizeColor)(obj.color, theme) + ";");
      if (obj.border) {
        if (obj.border.width)
          styles.push((0, _styledComponents.css)(["border-style:solid;border-width:", ";"], obj.border.width));
        if (obj.border.color)
          styles.push((0, _styledComponents.css)(["border-color:", ";"], (0, _colors.normalizeColor)(!obj.background && colorValue || obj.border.color || "border", theme)));
        if (obj.border.radius)
          styles.push((0, _styledComponents.css)(["border-radius:", ";"], obj.border.radius));
      } else if (obj.border === false)
        styles.push("border: none;");
      if (colorValue && !obj.border && !obj.background)
        styles.push("color: " + (0, _colors.normalizeColor)(colorValue, theme) + ";");
      if (obj.font) {
        if (obj.font.size) {
          styles.push("font-size: " + (theme.text[obj.font.size].size || obj.font.size) + ";");
        }
        if (obj.font.height) {
          styles.push("line-height: " + obj.font.height + ";");
        }
        if (obj.font.weight) {
          styles.push("font-weight: " + obj.font.weight + ";");
        }
      }
      if (obj.opacity) {
        var opacity = obj.opacity === true ? theme.global.opacity.medium : theme.global.opacity[obj.opacity] || obj.opacity;
        styles.push("opacity: " + opacity + ";");
      }
      if (obj.extend)
        styles.push(obj.extend);
      return styles;
    };
    exports.kindPartStyles = kindPartStyles;
    var ROUND_MAP = {
      full: "100%"
    };
    var roundStyle = function roundStyle2(data, responsive, theme) {
      var breakpoint = (0, _responsive.getBreakpointStyle)(theme, theme.box.responsiveBreakpoint);
      var styles = [];
      if (typeof data === "object") {
        var size = ROUND_MAP[data.size] || theme.global.edgeSize[data.size || "medium"] || data.size;
        var responsiveSize = responsive && breakpoint && breakpoint.edgeSize[data.size] && (breakpoint.edgeSize[data.size] || data.size);
        if (data.corner === "top") {
          styles.push((0, _styledComponents.css)(["border-top-left-radius:", ";border-top-right-radius:", ";"], size, size));
          if (responsiveSize) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-top-left-radius: " + responsiveSize + ";\n          border-top-right-radius: " + responsiveSize + ";\n        "));
          }
        } else if (data.corner === "bottom") {
          styles.push((0, _styledComponents.css)(["border-bottom-left-radius:", ";border-bottom-right-radius:", ";"], size, size));
          if (responsiveSize) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-bottom-left-radius: " + responsiveSize + ";\n          border-bottom-right-radius: " + responsiveSize + ";\n        "));
          }
        } else if (data.corner === "left") {
          styles.push((0, _styledComponents.css)(["border-top-left-radius:", ";border-bottom-left-radius:", ";"], size, size));
          if (responsiveSize) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-top-left-radius: " + responsiveSize + ";\n          border-bottom-left-radius: " + responsiveSize + ";\n        "));
          }
        } else if (data.corner === "right") {
          styles.push((0, _styledComponents.css)(["border-top-right-radius:", ";border-bottom-right-radius:", ";"], size, size));
          if (responsiveSize) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-top-right-radius: " + responsiveSize + ";\n          border-bottom-right-radius: " + responsiveSize + ";\n        "));
          }
        } else if (data.corner) {
          styles.push((0, _styledComponents.css)(["border-", "-radius:", ";"], data.corner, size));
          if (responsiveSize) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-" + data.corner + "-radius: " + responsiveSize + ";\n        "));
          }
        } else {
          styles.push((0, _styledComponents.css)(["border-radius:", ";"], size));
          if (responsiveSize) {
            styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n          border-radius: " + responsiveSize + ";\n        "));
          }
        }
      } else {
        var _size2 = data === true ? "medium" : data;
        styles.push((0, _styledComponents.css)(["border-radius:", ";"], ROUND_MAP[_size2] || theme.global.edgeSize[_size2] || _size2));
        var _responsiveSize = breakpoint && breakpoint.edgeSize[_size2];
        if (_responsiveSize) {
          styles.push((0, _mixins.breakpointStyle)(breakpoint, "\n        border-radius: " + _responsiveSize + ";\n      "));
        }
      }
      return styles;
    };
    exports.roundStyle = roundStyle;
    var TEXT_ALIGN_MAP = {
      center: "center",
      end: "right",
      justify: "justify",
      start: "left"
    };
    var textAlignStyle = (0, _styledComponents.css)(["text-align:", ";"], function(props) {
      return TEXT_ALIGN_MAP[props.textAlign];
    });
    exports.textAlignStyle = textAlignStyle;
    var ALIGN_ITEMS_MAP = {
      baseline: "baseline",
      center: "center",
      end: "flex-end",
      start: "flex-start",
      stretch: "stretch"
    };
    var alignStyle = (0, _styledComponents.css)(["align-items:", ";"], function(props) {
      var _ALIGN_ITEMS_MAP$prop;
      return (_ALIGN_ITEMS_MAP$prop = ALIGN_ITEMS_MAP[props.align]) != null ? _ALIGN_ITEMS_MAP$prop : props.align;
    });
    exports.alignStyle = alignStyle;
    var ALIGN_CONTENT_MAP = {
      around: "space-around",
      baseline: "baseline",
      between: "space-between",
      center: "center",
      evenly: "space-evenly",
      end: "flex-end",
      start: "flex-start",
      stretch: "stretch"
    };
    var alignContentStyle = (0, _styledComponents.css)(["align-content:", ";"], function(props) {
      var _ALIGN_CONTENT_MAP$pr;
      return (_ALIGN_CONTENT_MAP$pr = ALIGN_CONTENT_MAP[props.alignContent]) != null ? _ALIGN_CONTENT_MAP$pr : props.alignContent;
    });
    exports.alignContentStyle = alignContentStyle;
    var getSize = function getSize2(theme, size) {
      return theme.global.size[size] || size;
    };
    var widthObjectStyle = function widthObjectStyle2(width, theme) {
      var result = [];
      if (width.max)
        result.push((0, _styledComponents.css)(["max-width:", ";"], getSize(theme, width.max)));
      if (width.min)
        result.push((0, _styledComponents.css)(["min-width:", ";"], getSize(theme, width.min)));
      if (width.width)
        result.push((0, _styledComponents.css)(["width:", ";"], getSize(theme, width.width)));
      return result;
    };
    var widthStringStyle = function widthStringStyle2(width, theme) {
      return (0, _styledComponents.css)(["width:", ";"], getSize(theme, width));
    };
    var widthStyle = function widthStyle2(width, theme) {
      return typeof width === "object" ? widthObjectStyle(width, theme) : widthStringStyle(width, theme);
    };
    exports.widthStyle = widthStyle;
    var heightObjectStyle = function heightObjectStyle2(height, theme) {
      var result = [];
      if (height.max)
        result.push((0, _styledComponents.css)(["max-height:", ";"], getSize(theme, height.max)));
      if (height.min)
        result.push((0, _styledComponents.css)(["min-height:", ";"], getSize(theme, height.min)));
      if (height.width)
        result.push((0, _styledComponents.css)(["height:", ";"], getSize(theme, height.height)));
      if (height.height)
        result.push((0, _styledComponents.css)(["height:", ";"], getSize(theme, height.height)));
      return result;
    };
    var heightStringStyle = function heightStringStyle2(height, theme) {
      return (0, _styledComponents.css)(["height:", ";"], getSize(theme, height));
    };
    var heightStyle = function heightStyle2(height, theme) {
      return typeof height === "object" ? heightObjectStyle(height, theme) : heightStringStyle(height, theme);
    };
    exports.heightStyle = heightStyle;
  }
});

// node_modules/grommet/utils/object.js
var require_object = __commonJS({
  "node_modules/grommet/utils/object.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.removeUndefined = exports.isObject = exports.deepMerge = exports.deepFreeze = void 0;
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    var isObject = function isObject2(item) {
      return item && typeof item === "object" && !Array.isArray(item);
    };
    exports.isObject = isObject;
    var deepFreeze = function deepFreeze2(obj) {
      Object.keys(obj).forEach(function(key) {
        return key && isObject(obj[key]) && Object.freeze(obj[key]);
      });
      return Object.freeze(obj);
    };
    exports.deepFreeze = deepFreeze;
    var deepMerge = function deepMerge2(target) {
      for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
      }
      if (!sources.length) {
        return target;
      }
      var output = _extends({}, target);
      sources.forEach(function(source) {
        if (isObject(source)) {
          Object.keys(source).forEach(function(key) {
            if (isObject(source[key])) {
              if (!output[key]) {
                output[key] = _extends({}, source[key]);
              } else {
                output[key] = deepMerge2(output[key], source[key]);
              }
            } else {
              output[key] = source[key];
            }
          });
        }
      });
      return output;
    };
    exports.deepMerge = deepMerge;
    var removeUndefined = function removeUndefined2(obj) {
      var result = {};
      Object.keys(obj).forEach(function(key) {
        if (obj[key] !== void 0) {
          result[key] = obj[key];
        }
      });
      return result;
    };
    exports.removeUndefined = removeUndefined;
  }
});

// node_modules/grommet/utils/pagination.js
var require_pagination = __commonJS({
  "node_modules/grommet/utils/pagination.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.usePagination = exports.normalizeShow = void 0;
    var _react = require_react();
    var _excluded = ["data", "page", "step"];
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var normalizeShow = function normalizeShow2(showProp, step) {
      var page;
      if (typeof showProp === "number")
        page = Math.ceil((showProp + 1) / step);
      else if (typeof showProp === "object" && "page" in showProp)
        page = showProp.page;
      return page;
    };
    exports.normalizeShow = normalizeShow;
    var usePagination = function usePagination2(_ref) {
      var data = _ref.data, page = _ref.page, step = _ref.step, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
      var totalPages = data ? Math.ceil(data.length / step) : 0;
      var _useState = (0, _react.useState)(Math.min(page, totalPages) || 1), activePage = _useState[0], setActivePage = _useState[1];
      if (activePage > totalPages && (data == null ? void 0 : data.length) > 0)
        setActivePage(Math.max(totalPages, 1));
      var itemsBeginIndex = step * (activePage - 1);
      var itemsEndIndex = itemsBeginIndex + step;
      var currentItems = (0, _react.useMemo)(function() {
        if (Array.isArray(data))
          return data.slice(itemsBeginIndex, itemsEndIndex);
        return [];
      }, [data, itemsBeginIndex, itemsEndIndex]);
      var paginationProps = _extends({
        numberItems: data && data.length,
        onChange: function onChange(event) {
          return setActivePage(event.page);
        },
        page: activePage,
        step
      }, rest);
      return [currentItems, paginationProps];
    };
    exports.usePagination = usePagination;
  }
});

// node_modules/grommet/utils/PortalContext.js
var require_PortalContext = __commonJS({
  "node_modules/grommet/utils/PortalContext.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.PortalContext = void 0;
    var _react = _interopRequireDefault(require_react());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var PortalContext = _react["default"].createContext(void 0);
    exports.PortalContext = PortalContext;
  }
});

// node_modules/grommet/utils/use-isomorphic-layout-effect.js
var require_use_isomorphic_layout_effect = __commonJS({
  "node_modules/grommet/utils/use-isomorphic-layout-effect.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.useLayoutEffect = exports["default"] = void 0;
    var _react = require_react();
    var useLayoutEffect = typeof window !== "undefined" ? _react.useLayoutEffect : _react.useEffect;
    exports.useLayoutEffect = useLayoutEffect;
    var _default = useLayoutEffect;
    exports["default"] = _default;
  }
});

// node_modules/grommet/utils/refs.js
var require_refs = __commonJS({
  "node_modules/grommet/utils/refs.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.useForwardedRef = void 0;
    var _react = require_react();
    var _useIsomorphicLayoutEffect = require_use_isomorphic_layout_effect();
    var updateRef = function updateRef2(ref, innerRef) {
      if (!ref)
        return;
      if (typeof ref === "function") {
        ref(innerRef.current);
      } else {
        ref.current = innerRef.current;
      }
    };
    var useForwardedRef = function useForwardedRef2(ref) {
      var innerRef = (0, _react.useRef)(null);
      updateRef(ref, innerRef);
      (0, _useIsomorphicLayoutEffect.useLayoutEffect)(function() {
        return updateRef(ref, innerRef);
      });
      (0, _react.useEffect)(function() {
        return updateRef(ref, innerRef);
      });
      return innerRef;
    };
    exports.useForwardedRef = useForwardedRef;
  }
});

// node_modules/grommet/utils/use-keyboard.js
var require_use_keyboard = __commonJS({
  "node_modules/grommet/utils/use-keyboard.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.useKeyboard = exports["default"] = void 0;
    var _react = require_react();
    var useKeyboard = function useKeyboard2() {
      var _useState = (0, _react.useState)(), usingKeyboard = _useState[0], setUsingKeyboard = _useState[1];
      (0, _react.useEffect)(function() {
        var onMouseDown = function onMouseDown2() {
          return setUsingKeyboard(false);
        };
        var onKeyDown = function onKeyDown2() {
          return setUsingKeyboard(true);
        };
        document.addEventListener("mousedown", onMouseDown);
        document.addEventListener("keydown", onKeyDown);
        return function() {
          document.removeEventListener("mousedown", onMouseDown);
          document.removeEventListener("keydown", onKeyDown);
        };
      }, []);
      return usingKeyboard;
    };
    exports.useKeyboard = useKeyboard;
    var _default = useKeyboard;
    exports["default"] = _default;
  }
});

// node_modules/grommet/utils/index.js
var require_utils = __commonJS({
  "node_modules/grommet/utils/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var _animation = require_animation();
    Object.keys(_animation).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _animation[key])
        return;
      exports[key] = _animation[key];
    });
    var _mixins = require_mixins();
    Object.keys(_mixins).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _mixins[key])
        return;
      exports[key] = _mixins[key];
    });
    var _background = require_background();
    Object.keys(_background).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _background[key])
        return;
      exports[key] = _background[key];
    });
    var _border = require_border();
    Object.keys(_border).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _border[key])
        return;
      exports[key] = _border[key];
    });
    var _colors = require_colors();
    Object.keys(_colors).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _colors[key])
        return;
      exports[key] = _colors[key];
    });
    var _DOM = require_DOM();
    Object.keys(_DOM).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _DOM[key])
        return;
      exports[key] = _DOM[key];
    });
    var _graphics = require_graphics();
    Object.keys(_graphics).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _graphics[key])
        return;
      exports[key] = _graphics[key];
    });
    var _styles = require_styles();
    Object.keys(_styles).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _styles[key])
        return;
      exports[key] = _styles[key];
    });
    var _object = require_object();
    Object.keys(_object).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _object[key])
        return;
      exports[key] = _object[key];
    });
    var _pagination = require_pagination();
    Object.keys(_pagination).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _pagination[key])
        return;
      exports[key] = _pagination[key];
    });
    var _PortalContext = require_PortalContext();
    Object.keys(_PortalContext).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _PortalContext[key])
        return;
      exports[key] = _PortalContext[key];
    });
    var _refs = require_refs();
    Object.keys(_refs).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _refs[key])
        return;
      exports[key] = _refs[key];
    });
    var _responsive = require_responsive();
    Object.keys(_responsive).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _responsive[key])
        return;
      exports[key] = _responsive[key];
    });
    var _useKeyboard = require_use_keyboard();
    Object.keys(_useKeyboard).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports && exports[key] === _useKeyboard[key])
        return;
      exports[key] = _useKeyboard[key];
    });
  }
});

// dep:grommet_utils
var grommet_utils_default = require_utils();
export {
  grommet_utils_default as default
};
//# sourceMappingURL=grommet_utils.js.map
